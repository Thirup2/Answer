## 解法1: 双指针
```c
int removeDuplicates(int *nums, int numsSize)
{
    if (numsSize < 3) {
        return numsSize;
    }
    int i = 2, j = 2;
    while (j < numsSize) {
        if (nums[i-2] != nums[j]) {
            nums[i] = nums[j];
            ++i;
        }
        ++j;
    }
    return i;
}
```
- 首先由于每个元素最多出现两次, 所以当数组大小小于等于2时, 都可以保证其符合返回的数组要求, 直接返回即可
- 然后将`i`和`j`放在第三个元素的位置开始, 使用快慢指针的方法, `i`为慢指针, `j`为快指针
- 慢指针之前的数组即将要返回的数组, 所以只需要不断维护前面这部分数组的值就行了, 所以每次的比较只比较`i-2`和`j`两个位置的值就行了
- 如果`i-2`上的值等于`j`, 说明至少`i`这个位置上的值等于`i-2`, 于是将`j`滑到不等于`i-2`上的值的地方, 然后将`i`位置的值用现在的`j`位置的值覆盖
- 最后`i`的位置一定是元素的个数

### 理解
可以想象成是有两个数组, `i`指向将要返回的数组, `j`指向需要删除元素的数组. 将`j`指向的数组元素不断删除的过程就是向`i`中写入满足条件元素的过程.
当`j`中某个元素出现第一次和第二次的时候, 就将其写入`i`中的位置, 让`i`此时指向第二次写入之后的那个位置, 如果`j`和`i-2`位置的元素相同, 那么此时的`j`所指的元素就是应该删除的元素, 所以不对`i`所指的元素做任何操作, 只管移动`j`就行了, 直到`j`所指的元素不是`i-2`.